#include <Wire.h>
#include <I2C_graphical_LCD_display.h>
#include <VL53L0X.h>
#include <BH1750FVI.h>
#include <VEML6075.h>
#include <Adafruit_Sensor.h>
#include <Adafruit_BME280.h>
#include "Adafruit_SGP30.h"
#include <MCP3221.h>
#include <Adafruit_LSM9DS1.h>

#define BLYNK_PRINT Serial
#include <WiFi.h>
#include <WiFiClient.h>
#include <BlynkSimpleEsp32.h>

int var = 0;

#define  pump   16
#define  wind   17

#define PWMA 14
#define PWMB 15

#include "TLC59108.h"
#define HW_RESET_PIN 0 // Только програмнный сброс
#define I2C_ADDR TLC59108::I2C_ADDR::BASE
TLC59108 leds(I2C_ADDR + 7); // Без перемычек добавляется 3 бита адреса

#define SOIL_MOISTURE    25
#define SOIL_TEMPERATURE 26
const float air_value1 = 1587.0;
const float water_value1 = 800.0;
const float moisture_01 = 0.0;
const float moisture_1001 = 100.0;

#include "mcp3021.h"
uint8_t adcDeviceId =  0b00000001; // Адрес микросхемы A0
MCP3021 mcp3021;
const float air_value = 637.0;
const float water_value = 335.0;
const float moisture_0 = 0.0;
const float moisture_100 = 100.0;

#define sensor_addr 0x39
float ir_data = 0;
float vis_data = 0;

VEML6075 veml6075;
VL53L0X lox;
BH1750FVI LightSensor_1;
Adafruit_BME280 bme280;
I2C_graphical_LCD_display lcd;
Adafruit_SGP30 sgp30;
Adafruit_LSM9DS1 lsm = Adafruit_LSM9DS1();

#define HIGH_ACCURACY

#define UPDATE_TIMER 500
BlynkTimer timer_update;

const byte DEV_ADDR = 0x4D;  // Адрес микросхемы A0
MCP3221 mcp3221(DEV_ADDR);

#include "PCA9536.h"
PCA9536 pca9536;
const byte picture [] PROGMEM = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0x80, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xE0, 0xE0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0,
  0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
  0xF0, 0xF0, 0xE0, 0xE0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
  0x80, 0xC0, 0xE0, 0xE0, 0xE0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0x80,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
  0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0xFE,
  0xF8, 0xF0, 0xE0, 0xF0, 0xF8, 0xFC, 0x7F, 0x3F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
  0x00, 0xF8, 0xFE, 0xFF, 0xFF, 0xFF, 0x1F, 0x07, 0x03, 0x03, 0x01, 0xE1, 0xE1, 0xE1, 0xE3, 0xE3,
  0xE3, 0xE3, 0xE1, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF8, 0xF8, 0xF8,
  0xF8, 0xF9, 0xFF, 0xFF, 0xFF, 0xDF, 0x8F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xFC, 0xFF, 0xFF,
  0xFF, 0x0F, 0x03, 0xC3, 0xC1, 0xC0, 0xC0, 0xC4, 0xFC, 0xF8, 0xF9, 0xF1, 0x03, 0x07, 0x1F, 0xFF,
  0xFF, 0xFE, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00,
  0x03, 0x07, 0x0F, 0x07, 0x03, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
  0x00, 0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFC, 0xF8, 0xF0, 0xF0, 0xF1, 0xF1, 0xF1, 0xFF, 0xFF,
  0xFF, 0x7F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xF1, 0xF1, 0xF1,
  0xF1, 0xF1, 0xF1, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0xFC, 0xF0, 0xE0, 0xE1, 0xC3, 0xC7, 0xC7, 0xC7, 0xC7, 0xC3, 0xE1, 0xF0, 0xF8, 0xFE, 0xFF,
  0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF,
  0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
  0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};
void setup ()
{
  timer_update.setInterval(UPDATE_TIMER, readSendData);
  Serial.begin(115200);
  // Инициализация датчика
  Wire.begin();
  lox.init();
  lox.setTimeout(500);
#if defined LONG_RANGE
  // lower the return signal rate limit (default is 0.25 MCPS)
  lox.setSignalRateLimit(0.1);
  // increase laser pulse periods (defaults are 14 and 10 PCLKs)
  lox.setVcselPulsePeriod(VL53L0X::VcselPeriodPreRange, 18);
  lox.setVcselPulsePeriod(VL53L0X::VcselPeriodFinalRange, 14);
#endif
#if defined HIGH_SPEED
  // reduce timing budget to 20 ms (default is about 33 ms)
  lox.setMeasurementTimingBudget(20000);
#elif defined HIGH_ACCURACY
  // increase timing budget to 200 ms
  lox.setMeasurementTimingBudget(200000);
#endif

  Wire.setClock(100000L);
  if (!veml6075.begin())
    Serial.println("VEML6075 not found!");

  LightSensor_1.begin();
  LightSensor_1.setMode(Continuously_High_Resolution_Mode);

  bool bme_status = bme280.begin();
  if (!bme_status)
    Serial.println("Could not find a valid BME280 sensor, check wiring!");

  if (!sgp30.begin())
    Serial.println("Sensor SGP30 not found!");

  init_sensor();

  while (!Serial) {
    delay(1); // will pause Zero, Leonardo, etc until serial console opens
  }
  Serial.println("LSM9DS1 data read demo");
  if (!lsm.begin())
  {
    Serial.println("Oops ... unable to initialize the LSM9DS1. Check your wiring!");
    while (1);
  }
  Serial.println("Found LSM9DS1 9DOF");
  lsm.setupAccel(lsm.LSM9DS1_ACCELRANGE_2G);
  lsm.setupMag(lsm.LSM9DS1_MAGGAIN_4GAUSS);
  lsm.setupGyro(lsm.LSM9DS1_GYROSCALE_245DPS);

  lcd.begin();

  pca9536.reset();
  pca9536.setMode(IO_OUTPUT);
  pinMode( pump, OUTPUT );
  pinMode( wind, OUTPUT );
  digitalWrite(pump, LOW);
  digitalWrite(wind, LOW);

  ledcAttachPin(PWMA, 1);
  ledcAttachPin(PWMB, 2);
  ledcSetup(1, 50, 10);
  ledcSetup(2, 50, 10);

  leds.init(HW_RESET_PIN);
  leds.setLedOutputMode(TLC59108::LED_MODE::PWM_IND);

  mcp3021.begin(adcDeviceId);
}

void loop ()
{
  timer_update.run();
}

void readSendData() {
  float adc20 = mcp3021.readADC();
  float h20 = map(adc20, air_value, water_value, moisture_0, moisture_100);
  if (h20 > 20) {
    leds.setBrightness(2, 0xff);
  }
  else {
    leds.setBrightness(2, 0);
  }
  float adc01 = analogRead(SOIL_MOISTURE);
  float h11 = map(adc01, air_value1, water_value1, moisture_01, moisture_1001);
  if (h11 > 20) {
    leds.setBrightness(3, 0xff);
  }
  else {
    leds.setBrightness(3, 0);
  }
  float dist = lox.readRangeSingleMillimeters();
  Serial.println("Distance  = " + String(dist, 0) + " mm  ");
  if (dist < 150) {
    lcd.clear (0, 0, 128, 64, 0x00);
    var++;
    if (var == 7) {
      var = 0;
      lcd.gotoxy (0, 0);
      lcd.blit (picture, sizeof picture);
    }
  }
  measure();
}
void measure()
{
  switch (var) {
     3    case 1: {
        veml6075.poll();
        float uva = veml6075.getUVA();
        float uvb = veml6075.getUVB();
        float uv_index = veml6075.getUVIndex();
        float l = LightSensor_1.getAmbientLight();

        lcd.gotoxy (35, 53);
        lcd.string ("light int, lx" , false);
        char buf[8];
        sprintf(buf, "%d", (int)l);
        lcd.clear (10, 53, 32, 60, 0x00);
        lcd.gotoxy (10, 53);
        lcd.string (buf, false);

        lcd.gotoxy (35, 39);
        lcd.string ("UVA" , false);
        char buf1[8];
        sprintf(buf1, "%d", (int)uva);
        lcd.clear (10, 39, 32, 46, 0x00);
        lcd.gotoxy (10, 39);
        lcd.string (buf1, false);

        lcd.gotoxy (35, 22);
        lcd.string ("UVB" , false);
        char buf2[8];
        sprintf(buf2, "%d", (int)uvb);
        lcd.clear (10, 22, 32, 32, 0x00);
        lcd.gotoxy (10, 22);
        lcd.string (buf2, false);

        lcd.gotoxy (35, 3);
        lcd.string ("UV Index" , false);
        char buf3[8];
        sprintf(buf3, "%d", (int)uv_index);
        lcd.clear (10, 3, 32, 18, 0x00);
        lcd.gotoxy (10, 3);
        lcd.string (buf3, false);
        break;
      }
    case 2:
      {
        float eco2 = 0;
        float tvoc = 0;
        if (!sgp30.IAQmeasure())
        {
          Serial.println("Measurement failed!");
          return;
        }
        tvoc = sgp30.TVOC;
        eco2 = sgp30.eCO2;
        poll_sensor();

        lcd.gotoxy (40, 53);
        lcd.string ("TVOC, ppb" , false);
        char buf[8];
        sprintf(buf, "%d", (int)tvoc);
        lcd.clear (10, 53, 32, 60, 0x00);
        lcd.gotoxy (10, 53);
        lcd.string (buf, false);

        lcd.gotoxy (40, 39);
        lcd.string ("eCO2, ppm" , false);
        char buf1[8];
        sprintf(buf1, "%d", (int)eco2);
        lcd.clear (10, 39, 32, 46, 0x00);
        lcd.gotoxy (10, 39);
        lcd.string (buf1, false);

        lcd.gotoxy (40, 22);
        lcd.string ("IR" , false);
        char buf2[8];
        sprintf(buf2, "%d", (int)ir_data);
        lcd.clear (10, 22, 32, 32, 0x00);
        lcd.gotoxy (10, 22);
        lcd.string (buf2, false);

        lcd.gotoxy (40, 3);
        lcd.string ("VISIBLE" , false);
        char buf3[8];
        sprintf(buf3, "%d", (int)vis_data);
        lcd.clear (10, 3, 32, 18, 0x00);
        lcd.gotoxy (10, 3);
        lcd.string (buf3, false);
        break;
      }
    case 3:
      {
        float t = bme280.readTemperature();
        float h = bme280.readHumidity();
        float p = bme280.readPressure() / 100.0F;
        float adc0 = mcp3221.getVoltage();

        lcd.gotoxy (40, 53);
        lcd.string ("Temperature, C" , false);
        char buf[8];
        sprintf(buf, "%d", (int)t);
        lcd.clear (10, 53, 32, 60, 0x00);
        lcd.gotoxy (10, 53);
        lcd.string (buf, false);

        lcd.gotoxy (40, 39);
        lcd.string ("Humidity, %" , false);
        char buf1[8];
        sprintf(buf1, "%d", (int)h);
        lcd.clear (10, 39, 32, 46, 0x00);
        lcd.gotoxy (10, 39);
        lcd.string (buf1, false);

        lcd.gotoxy (40, 22);
        lcd.string ("Pressure, hPa" , false);
        char buf2[8];
        sprintf(buf2, "%d", (int)p);
        lcd.clear (10, 22, 32, 32, 0x00);
        lcd.gotoxy (10, 22);
        lcd.string (buf2, false);

        lcd.gotoxy (40, 3);
        lcd.string ("Sound level" , false);
        char buf3[8];
        sprintf(buf3, "%d", (int)adc0);
        lcd.clear (10, 3, 32, 18, 0x00);
        lcd.gotoxy (10, 3);
        lcd.string (buf3, false);
        break;
      }
    case 4:
      {
        lsm.read();
        sensors_event_t a, m, g, temp;
        lsm.getEvent(&a, &m, &g, &temp);

        lcd.gotoxy (40, 53);
        lcd.string ("AccelX, m/s^2" , false);
        char buf[8];
        sprintf(buf, "%d", (int)a.acceleration.x);
        lcd.clear (10, 53, 32, 60, 0x00);
        lcd.gotoxy (10, 53);
        lcd.string (buf, false);

        lcd.gotoxy (40, 39);
        lcd.string ("AccelY, m/s^2" , false);
        char buf1[8];
        sprintf(buf1, "%d", (int)a.acceleration.y);
        lcd.clear (10, 39, 32, 46, 0x00);
        lcd.gotoxy (10, 39);
        lcd.string (buf1, false);

        lcd.gotoxy (40, 22);
        lcd.string ("AccelZ, m/s^2" , false);
        char buf2[8];
        sprintf(buf2, "%d", (int)a.acceleration.z);
        lcd.clear (10, 22, 32, 32, 0x00);
        lcd.gotoxy (10, 22);
        lcd.string (buf2, false);

        break;
      }
    case 5:
      {
        pca9536.setState(IO0, IO_HIGH);
        pca9536.setState(IO1, IO_LOW);
        pca9536.setState(IO2, IO_LOW);
        pca9536.setState(IO3, IO_LOW);
        leds.setBrightness(6, 0xff);
        leds.setBrightness(3, 0xff);
        leds.setBrightness(0, 0xff);
        delay(100);
        pca9536.setState(IO0, IO_LOW);
        pca9536.setState(IO1, IO_HIGH);
        pca9536.setState(IO2, IO_LOW);
        pca9536.setState(IO3, IO_LOW);
        leds.setBrightness(4, 0xff);
        leds.setBrightness(1, 0xff);
        leds.setBrightness(5, 0xff);
        leds.setBrightness(3, 0);
        delay(100);
        pca9536.setState(IO0, IO_LOW);
        pca9536.setState(IO1, IO_LOW);
        pca9536.setState(IO2, IO_HIGH);
        pca9536.setState(IO3, IO_LOW);
        leds.setBrightness(5, 0);
        leds.setBrightness(2, 0xff);
        delay(100);
        pca9536.setState(IO0, IO_LOW);
        pca9536.setState(IO1, IO_LOW);
        pca9536.setState(IO2, IO_LOW);
        pca9536.setState(IO3, IO_HIGH);
        delay(100);
        pca9536.setState(IO_LOW);
        delay(100);
        digitalWrite(pump, HIGH);
        delay(100);
        digitalWrite(pump, LOW);
        delay(100);
        digitalWrite(wind, HIGH);
        delay(100);
        digitalWrite(wind, LOW);
        leds.setBrightness(1, 0);
        leds.setBrightness(2, 0);
        leds.setBrightness(3, 0);
        leds.setBrightness(4, 0);
        leds.setBrightness(5, 0);
        leds.setBrightness(6, 0);
        leds.setBrightness(0, 0);
        delay(100);
        break;
      }
    case 6:
      {
        float value = 0;
        for (value = 0 ; value <= 100; value += 1)
        {
          motorA_setpower(value, false);
          motorB_setpower(value, false);
          lcd.gotoxy (40, 22);
          lcd.string ("Power" , false);
          char buf2[8];
          sprintf(buf2, "%d", (int)value);
          lcd.clear (10, 22, 32, 32, 0x00);
          lcd.gotoxy (10, 22);
          lcd.string (buf2, false);
          delay(5);
        }
        for (value = 100 ; value >= 0; value -= 1)
        {
          motorA_setpower(value, false);
          motorB_setpower(value, false);
          lcd.gotoxy (40, 22);
          lcd.string ("Power" , false);
          char buf2[8];
          sprintf(buf2, "%d", (int)value);
          lcd.clear (10, 22, 32, 32, 0x00);
          lcd.gotoxy (10, 22);
          lcd.string (buf2, false);
          delay(5);
        }
      }
     }
}
void init_sensor() {
  Wire.begin();
  Wire.beginTransmission(sensor_addr);
  Wire.write(0x81);       // Регистр времени интегрирования АЦП
  Wire.write(0b00111111); // 180 мс, 65535 циклов
  Wire.endTransmission();
  Wire.beginTransmission(sensor_addr);
  Wire.write(0x83);       // Регистр времени ожидания
  Wire.write(0b00111111); // 180 мс
  Wire.endTransmission();
  Wire.beginTransmission(sensor_addr);
  Wire.write(0x90);         // Регистр усиления
  Wire.write(0b00000000);   // Усиление 1x
  Wire.endTransmission();
  Wire.beginTransmission(sensor_addr);
  Wire.write(0x80);       // Регистр управления питанием
  Wire.write(0b00001011); // Включение ожидания, генератора, АЦП и ALS сенсора
  Wire.endTransmission();
}

void poll_sensor() {
  unsigned int sensor_data[4];
  Wire.beginTransmission(sensor_addr);
  Wire.write(0x94); // Начальный адрес регистров данных
  Wire.endTransmission();
  Wire.requestFrom(sensor_addr, 4);
  if (Wire.available() == 4) {
    sensor_data[0] = Wire.read();
    sensor_data[1] = Wire.read();
    sensor_data[2] = Wire.read();
    sensor_data[3] = Wire.read();
  }
  ir_data   = sensor_data[3] * 256.0 + sensor_data[2];
  vis_data = sensor_data[1] * 256.0 + sensor_data[0];
}
void motorA_setpower(float pwr, bool invert)
{
  // Проверка, инвертирован ли мотор
  if (invert)
  {
    pwr = -pwr;
  }
  // Проверка диапазонов
  if (pwr < -100)
  {
    pwr = -100;
  }
  if (pwr > 100)
  {
    pwr = 100;
  }
  int pwmvalue = fabs(pwr) * 10.23;
  ledcWrite(1, pwmvalue);
}
void motorB_setpower(float pwr, bool invert)
{
  // Проверка, инвертирован ли мотор
  if (invert)
  {
    pwr = -pwr;
  }
  // Проверка диапазонов
  if (pwr < -100)
  {
    pwr = -100;
  }
  if (pwr > 100)
  {
    pwr = 100;
  }
  int pwmvalue = fabs(pwr) * 10.23;
  ledcWrite(2, pwmvalue);
}
